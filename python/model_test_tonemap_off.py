# model_test_tonemap_off.py  Test HDRP model predictions without tonemapping

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from hdrp import srgb, srgbinv

# choose whether to test results from Unity project render_random with Lambertian or unlit material
testLambertian = True

# load data generated by render_random
fname = f'data/tonemap_off/data_L{int(testLambertian)}_T0.txt'
df = pd.read_csv(fname)

# discard samples that may be maxed out
k = (df[['v_r','v_g','v_b']] <= 0.99).all(axis=1)
df = df[k]

# create numpy arrays for model parameters
e = df['e'].to_numpy().reshape((-1,1))       # exposure
m = df[['m_r','m_g','m_b']].to_numpy()       # material color
d = df[['d_r','d_g','d_b']].to_numpy()       # directional light color
a = df[['a_r','a_g','a_b']].to_numpy()       # ambient light color
v = df[['v_r','v_g','v_b']].to_numpy()       # post-processed color
i_d = df['i_d'].to_numpy().reshape((-1,1))   # directional light intensity
i_a = df['i_a'].to_numpy().reshape((-1,1))   # directional light intensity
l = df[['l_x','l_y','l_z']].to_numpy()       # lighting direction
n = df[['n_x','n_y','n_z']].to_numpy()       # plane surface normal
costheta = (l*n).sum(axis=1, keepdims=True)  # cosine of angle between lighting direction and plane surface normal

# apply rendering model to get predictions for unprocessed color coordinates u_k
if testLambertian:
    c = 0.823
    u_hat = c * srgb(m) * ( i_d * srgb(d) * costheta.clip(min=0) / np.pi + i_a * a ) / (2**e)
else:
    u_hat = srgb(m)

# apply inverse sRGB nonlinearity to get post-processed color coordinates v_k
v_hat = srgbinv(u_hat)

# plot predictions for v_k against actual v_k
plotFour = testLambertian  # flag whether to plot all four panels, or just panels (a) and (b)
if plotFour:
    fig = plt.figure(figsize=(13,12))
    ax1 = fig.add_subplot(2,2,1)
else:
    fig = plt.figure(figsize=(13,5.5))
    ax1 = fig.add_subplot(1,2,1)
xylim = np.array([0,1.1])
k = np.random.randint(low=0, high=v.shape[0], size=50)
for i in range(3):
    ax1.scatter(v[k,i], v_hat[k,i], color='rgb'[i])
ax1.plot(xylim, xylim, 'k-')
ax1.legend(['red channel','green channel','blue channel'], frameon=False, loc='upper left')
ax1.set_xlabel('actual $v_k$', fontsize=18)
ax1.set_ylabel('predicted $v_k$', fontsize=18)
ax1.set_xlim(xylim)
ax1.set_ylim(xylim)
ax1.set_aspect(1)
ax1.text(0.92,0.75,'(a)',fontsize=24)

# plot prediction error (argument 'err') against a scene parameter (argument 'x')
def plot_err(ax, x, err, xlabel, letter):
    xlim = np.array([0,1])
    for i in range(3):
        ax.scatter(x[:,i], err[:,i], color='rgb'[i])
    ax.legend(['red channel','green channel','blue channel'], frameon=False, loc='lower right')
    ax.plot(xlim,(-1/255)*np.ones(2),'k-')
    ax.plot(xlim,(1/255)*np.ones(2),'k-')
    ax.set_xlabel(xlabel, fontsize=18)
    ax.set_ylabel('prediction error', fontsize=18)
    ax.set_xlim(xlim)
    ax.set_ylim((-0.02,0.02))
    ax.set_aspect(1./ax2.get_data_ratio())
    ax.text(0.8,0.015,letter,fontsize=24)

# plot prediction error in v_k against actual v_k
if plotFour:
    ax2 = fig.add_subplot(2,2,2)
else:
    ax2 = fig.add_subplot(1,2,2)
k = np.random.randint(low=0, high=v.shape[0], size=200)
plot_err(ax2, v[k,:], v_hat[k,:] - v[k,:], 'actual $v_k$', '(b)')
mae = np.median(abs(v-v_hat))
ax2.text(0.1, -0.018, f'error = {255*mae:.2f} / 255', fontsize=12)

if plotFour:
    
    # plot prediction error in v_k against material color coordinates m_k
    ax3 = fig.add_subplot(2,2,3)
    plot_err(ax3, m[k,:], v_hat[k,:] - v[k,:], 'material color $m_k$', '(c)')
    mae = np.median(abs(v - v_hat))
    ax3.text(0.1, -0.018, f'error = {255 * mae:.2f} / 255', fontsize=12)

    # plot prediction error in v_k against actual v_k, without low values of m_k
    ax4 = fig.add_subplot(2,2,4)
    vv = v[k,:]
    vv[m[k,:] < 0.2] = np.nan;
    plot_err(ax4, vv, v_hat[k,:] - v[k,:], 'actual $v_k$', '(d)')

    mae = np.median(abs(v[m>=0.2] - v_hat[m>=0.2]))
    ax4.text(0.1, -0.018, f'error = {255 * mae:.2f} / 255', fontsize=12)

plt.savefig(f'figures/model_test_tonemap_off_L{int(testLambertian)}.pdf', bbox_inches='tight')
plt.show()
