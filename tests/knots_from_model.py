# knots_from_model.py  Estimate knot points by optimizing HDRP model predictions

import os
import numpy as np
import pandas as pd
from scipy import optimize
from hdrp import srgb, srgbinv, TonemapCube, cubetag

# choose whether to test results from Unity project render_random with
# Lambertian or unlit material
testLambertian = True

# choose cube file
cubefile = 'cube/identity.cube'
tonemap = TonemapCube(cubefile)

# load data generated by Unity project render_random for this condition
fname = f'data/data_L{int(testLambertian)}_T1{cubetag(cubefile)}.txt'
df = pd.read_csv(fname)

# discard samples that may be maxed out
k = (df[['v_r','v_g','v_b']] <= 0.99).all(axis=1)
df = df[k]

# discard samples with low material color coordinates
k = (df[['m_r','m_g','m_b']] >= 0.20).all(axis=1)
df = df[k]

# create numpy arrays for model parameters
e = df['e'].to_numpy().reshape((-1,1))       # exposure
m = df[['m_r','m_g','m_b']].to_numpy()       # material color
d = df[['d_r','d_g','d_b']].to_numpy()       # directional light color
a = df[['a_r','a_g','a_b']].to_numpy()       # ambient light color
v = df[['v_r','v_g','v_b']].to_numpy()       # post-processed color
i_d = df['i_d'].to_numpy().reshape((-1,1))   # directional light intensity
i_a = df['i_a'].to_numpy().reshape((-1,1))   # directional light intensity
l = df[['l_x','l_y','l_z']].to_numpy()       # lighting direction
n = df[['n_x','n_y','n_z']].to_numpy()       # plane surface normal
costheta = (l*n).sum(axis=1, keepdims=True)  # cosine of angle between lighting direction and plane surface normal

# apply Lambertian or unlit rendering model
if testLambertian:
    c = 0.822
    u_hat = c * srgb(m) * ( i_d * srgb(d) * costheta.clip(min=0) / np.pi + i_a * a ) / (2**e)
else:
    u_hat = srgb(m)

# constraint: each knot point is less than the next knot point
nknot = tonemap.u_knot[2:18].size
A1 = np.identity(nknot) + np.diag((nknot-1)*(-1,), 1)
A1 = A1[:-1,:]
lb1 = np.full((A1.shape[0],), -np.inf)
ub1 = np.zeros((A1.shape[0],))

# constraint: the third knot point is at least 1e-8
A2 = np.zeros((1, nknot))
A2[0,0] = 1
lb2 = np.array((1e-8,))
ub2 = np.array((np.inf,))

# constraint: the 19th knot point is less than 1.4
A3 = np.zeros((1, nknot))
A3[0,-1] = 1
lb3 = np.array((-np.inf,))
ub3 = np.array((1.4,))

# combine constraints
A = np.vstack((A1, A2, A3))
lb = np.concatenate((lb1, lb2, lb3))
ub = np.concatenate((ub1, ub2, ub3))
cons = optimize.LinearConstraint(A=A, lb=lb, ub=ub)

# define objective function
def errfn(param):

    # check that constraints are satisifed
    # (the tonemapping function throws an exception if they're not)
    x = A @ param
    if not ((lb <= x) & (x <= ub)).all():
        return np.inf
    
    # find prediction error with these knot points
    tonemap.u_knot[2:18] = param
    t_hat = tonemap.apply(u_hat)
    v_hat = srgbinv(t_hat)
    return ((v-v_hat)**2).sum()

# find knot points that optimize prediction accuracy
pinit = tonemap.u_knot[2:18]
r = optimize.minimize(errfn, pinit, constraints=cons)
print(r)

# assign new points to tonemapping object, and print knot points
tonemap.u_knot[2:18] = r.x
print(np.array2string(tonemap.u_knot, formatter={'float' : lambda u : f'{u:.6g}'}, separator=', ', max_line_width=np.inf))
