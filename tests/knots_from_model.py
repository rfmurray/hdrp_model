# knots_from_model.py  Estimate knot points by optimizing HDRP model predictions

import os
import numpy as np
import pandas as pd
from scipy import optimize
import matplotlib.pyplot as plt
from hdrp import srgb, srgbinv, TonemapCube

# choose whether to test results from Unity project render_random with
# Lambertian or unlit material
testLambertian = True

# choose cube file
cubefile = 'identity.cube'
tonemap = TonemapCube(cubefile)
#tonemap.u_knot[2:18] = np.linspace(0.001, 1, 16)
#tonemap.u_knot[18:32] = np.linspace(2, 50, 14)

for passnum in range(2):
    
    # load data generated by Unity project render_random for this condition
    cubefilebase, _ = os.path.splitext(cubefile)
    fname = f'data_L{int(testLambertian)}_T1_{cubefilebase}.txt'
    df = pd.read_csv(fname)
    
    # discard samples that may be maxed out
    k = (df[['v_r','v_g','v_b']] <= 0.99).all(axis=1)
    df = df[k]
    
    # create numpy arrays for model parameters
    e = df['e'].to_numpy().reshape((-1,1))       # exposure
    m = df[['m_r','m_g','m_b']].to_numpy()       # material color
    d = df[['d_r','d_g','d_b']].to_numpy()       # directional light color
    a = df[['a_r','a_g','a_b']].to_numpy()       # ambient light color
    v = df[['v_r','v_g','v_b']].to_numpy()       # post-processed color
    i_d = df['i_d'].to_numpy().reshape((-1,1))   # directional light intensity
    i_a = df['i_a'].to_numpy().reshape((-1,1))   # directional light intensity
    l = df[['l_x','l_y','l_z']].to_numpy()       # lighting direction
    n = df[['n_x','n_y','n_z']].to_numpy()       # plane surface normal
    costheta = (l*n).sum(axis=1, keepdims=True)  # cosine of angle between lighting direction and plane surface normal
    
    # apply Lambertian or unlit rendering model
    if testLambertian:
        c = 0.822
        u_hat = c * srgb(m) * ( i_d * srgb(d) * costheta.clip(min=0) / np.pi + i_a * a ) / (2**e)
    else:
        u_hat = srgb(m)
    
    # apply tonemapping
    t_hat = tonemap.apply(u_hat)
    
    # apply inverse sRGB nonlinearity to get post-processed color coordinates v_k
    v_hat = srgbinv(t_hat)
    
    # plot predicted post-processed color coordinates v_k against actual v_k
    fig = plt.figure(figsize=(13,12))
    ax1 = fig.add_subplot(2,2,1)
    xylim = np.array([0,1.1])
    k = np.random.randint(low=0, high=v.shape[0], size=50)
    for i in range(3):
        ax1.scatter(v[k,i], v_hat[k,i], color='rgb'[i])
    ax1.plot(xylim, xylim, 'k-')
    ax1.legend(['red channel','green channel','blue channel'], frameon=False, loc='upper left')
    ax1.set_xlabel('actual $v_k$', fontsize=18)
    ax1.set_ylabel('predicted $v_k$', fontsize=18)
    ax1.set_xlim(xylim)
    ax1.set_ylim(xylim)
    ax1.set_aspect(1)
    ax1.text(0.85,0.1,'(a)',fontsize=24)
    
    # plot prediction error against another scene parameter
    def plot_err(ax, x, err, xlabel, letter):
        xlim = np.array([0,1])
        for i in range(3):
            ax.scatter(x[:,i], err[:,i], color='rgb'[i])
        ax.legend(['red channel','green channel','blue channel'], frameon=False, loc='lower right')
        ax.plot(xlim,(-1/255)*np.ones(2),'k-')
        ax.plot(xlim,(1/255)*np.ones(2),'k-')
        ax.set_xlabel(xlabel, fontsize=18)
        ax.set_ylabel('prediction error', fontsize=18)
        ax.set_xlim(xlim)
        ax.set_ylim((-0.02,0.01))
        ax.set_aspect(1./ax2.get_data_ratio())
        ax.text(0.85,-0.012,letter,fontsize=24)
    
    # plot prediction error in v_k against actual v_k
    ax2 = fig.add_subplot(2,2,2)
    k = np.random.randint(low=0, high=v.shape[0], size=200)
    plot_err(ax2, v[k,:], v_hat[k,:] - v[k,:], 'actual $v_k$', '(b)')
    
    # plot prediction error in v_k against m_k
    ax3 = fig.add_subplot(2,2,3)
    plot_err(ax3, m[k,:], v_hat[k,:] - v[k,:], 'material color $m_k$', '(c)')
    
    # plot prediction error in v_k against actual v_k, without low values of m_k
    ax4 = fig.add_subplot(2,2,4)
    vv = v[k,:]
    vv[m[k,:] < 0.2] = np.nan;
    plot_err(ax4, vv, v_hat[k,:] - v[k,:], 'actual $v_k$', '(d)')
    
    plt.savefig(f'model_test_2_L{int(testLambertian)}_T1_{cubefilebase}_pass{passnum+1}.eps', bbox_inches='tight')
    plt.show()
    
    if passnum==1:
        break
    
    # constraint: u^star_i <= u^star_(i+1)
    nknot = tonemap.u_knot[2:18].size
    A1 = np.identity(nknot) + np.diag((nknot-1)*(-1,), 1)
    A1 = A1[:-1,:]
    lb1 = np.full((A1.shape[0],), -np.inf)
    ub1 = np.zeros((A1.shape[0],))
    
    # constraint: u^star_3 >= 1e-8
    A2 = np.zeros((1, nknot))
    A2[0,0] = 1
    lb2 = np.array((1e-8,))
    ub2 = np.array((np.inf,))
    
    # constraint: u^star_19 <= 1.4
    A3 = np.zeros((1, nknot))
    A3[0,-1] = 1
    lb3 = np.array((-np.inf,))
    ub3 = np.array((1.4,))
    
    # combine constraints
    A = np.vstack((A1, A2, A3))
    lb = np.concatenate((lb1, lb2, lb3))
    ub = np.concatenate((ub1, ub2, ub3))
    cons = optimize.LinearConstraint(A=A, lb=lb, ub=ub)
    
    # discard points with low values of material color coordinates
    k = (m >= 0.2).all(axis=1)
    u_hat = u_hat[k,:]
    v = v[k,:]
    
    def errfn(param):
        x = A @ param
        if not ((lb <= x) & (x <= ub)).all():
            return np.inf
        
        tonemap.u_knot[2:18] = param
        t_hat = tonemap.apply(u_hat)
        v_hat = srgbinv(t_hat)
        return ((v-v_hat)**2).sum()
    
    pinit = tonemap.u_knot[2:18]
    r = optimize.minimize(errfn, pinit, constraints=cons)
    print(r)
    
    tonemap.u_knot[2:18] = r.x
    print('u_knot = ' + np.array2string(tonemap.u_knot, formatter={'float' : lambda u : f'{u:.9f}'}, separator=', '))
