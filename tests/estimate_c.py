# estimate_c.py  Find rendering scale constant c for Lambertian materials
#                (see equation (2) in main text)

import numpy as np
import pandas as pd
from scipy import stats
import matplotlib.pyplot as plt
from hdrp import srgb

# load data generated by Unity project model_test with a Lambertian
# material and no tonemapping
df = pd.read_csv('data/data_L1_T0.txt')

# discard samples that may be maxed out
k = (df[['v_r','v_g','v_b']] <= 0.99).all(axis=1)
df = df[k]

# create numpy arrays for model parameters
e = df['e'].to_numpy().reshape((-1,1))       # exposure
m = df[['m_r','m_g','m_b']].to_numpy()       # material color
d = df[['d_r','d_g','d_b']].to_numpy()       # directional light color
a = df[['a_r','a_g','a_b']].to_numpy()       # ambient light color
v = df[['v_r','v_g','v_b']].to_numpy()       # post-processed color
i_d = df['i_d'].to_numpy().reshape((-1,1))   # directional light intensity
i_a = df['i_a'].to_numpy().reshape((-1,1))   # directional light intensity
l = df[['l_x','l_y','l_z']].to_numpy()       # lighting direction
n = df[['n_x','n_y','n_z']].to_numpy()       # plane surface normal
costheta = (l*n).sum(axis=1, keepdims=True)  # cosine of angle between lighting direction and plane surface normal

# apply Lambertian rendering model to get predicted rendered color
# coordinates u_k, without rendering scale constant c
u_hat = srgb(m) * ( i_d * srgb(d) * costheta.clip(min=0) / np.pi + i_a * a ) / (2**e)

# apply sRGB nonlinearity to get actual rendered color coordinates u_k
u = srgb(v)

# discard values outside [ 0, 0.95 ]
k = (u < 0) | (u > 0.95) | (u_hat < 0) | (u_hat > 0.95)
u[k] = np.nan
u_hat[k] = np.nan

# plot predicted rendered color coordinates u_k against actual coordinates
xylim = np.array([0,1.1])
k = np.random.randint(low=0, high=u.shape[0], size=100)
for i in range(3):
    plt.scatter(u[k,i], u_hat[k,i], color='rgb'[i])
plt.plot(xylim, xylim, 'k-')
plt.legend(['red channel','green channel','blue channel'], frameon=False)
plt.xlabel('actual $u_k$', fontsize=18)
plt.ylabel('predicted $u_k$', fontsize=18)
plt.xlim(xylim)
plt.ylim(xylim)
plt.gca().set_aspect(1)

# find regression slope
k = ~np.isnan(u)
r = stats.linregress(u[k], u_hat[k])
print(r)

# add regression line to plot
plt.plot(xylim, r.slope*xylim, 'r-')
plt.savefig('figures/model_test_1.eps')
plt.show()

# the scale constant that will adjust the predicted renderd color
# coordinates u_k so that they fall on the line y=x is the inverse
# of the regression slope
c = 1/r.slope
print(f'rendering model scale constant: c = {c:.3f}');
