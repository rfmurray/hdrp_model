# model_tests.py  Test HDRP model model predictions

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from hdrp import srgb, srgbinv, TonemapCube, cubetag

# choose whether to test results from model_test Unity project with
# Lambertian or unlit material
testLambertian = True

# choose cube file
# - if filename is empty, then test is done without tonemapping
cubefile = 'cube/identity.cube'
cubefile = ''

# load data generated by Unity project render_random for this condition
testTonemapping = len(cubefile) > 0
fname = f'data/data_L{int(testLambertian)}_T{int(testTonemapping)}{cubetag(cubefile)}.txt'
df = pd.read_csv(fname)

# discard samples that may be maxed out
k = (df[['v_r','v_g','v_b']] <= 0.99).all(axis=1)
df = df[k]

# create numpy arrays for model parameters
e = df['e'].to_numpy().reshape((-1,1))       # exposure
m = df[['m_r','m_g','m_b']].to_numpy()       # material color
d = df[['d_r','d_g','d_b']].to_numpy()       # directional light color
a = df[['a_r','a_g','a_b']].to_numpy()       # ambient light color
v = df[['v_r','v_g','v_b']].to_numpy()       # post-processed color
i_d = df['i_d'].to_numpy().reshape((-1,1))   # directional light intensity
i_a = df['i_a'].to_numpy().reshape((-1,1))   # directional light intensity
l = df[['l_x','l_y','l_z']].to_numpy()       # lighting direction
n = df[['n_x','n_y','n_z']].to_numpy()       # plane surface normal
costheta = (l*n).sum(axis=1, keepdims=True)  # cosine of angle between lighting direction and plane surface normal

# apply Lambertian rendering model to get predicted rendered color
# coordinates u_k, without rendering scale constant c
if testLambertian:
    c = 0.822
    u_hat = c * srgb(m) * ( i_d * srgb(d) * costheta.clip(min=0) / np.pi + i_a * a ) / (2**e)
else:
    u_hat = srgb(m)

# apply tonemapping
if testTonemapping:
    tonemap = TonemapCube(cubefile)
    t_hat = tonemap.apply(u_hat)
else:
    t_hat = u_hat

# apply inverse sRGB nonlinearity to get post-processed color coordinates v_k
v_hat = srgbinv(t_hat)

# plot predicted post-processed color coordinates v_k against actual v_k
fig = plt.figure(figsize=(13,12))
ax1 = fig.add_subplot(2,2,1)
xylim = np.array([0,1.1])
k = np.random.randint(low=0, high=v.shape[0], size=50)
for i in range(3):
    ax1.scatter(v[k,i], v_hat[k,i], color='rgb'[i])
ax1.plot(xylim, xylim, 'k-')
ax1.legend(['red channel','green channel','blue channel'], frameon=False, loc='upper left')
ax1.set_xlabel('actual $v_k$', fontsize=18)
ax1.set_ylabel('predicted $v_k$', fontsize=18)
ax1.set_xlim(xylim)
ax1.set_ylim(xylim)
ax1.set_aspect(1)
ax1.text(0.85,0.1,'(a)',fontsize=24)

# plot prediction error against another scene parameter
def plot_err(ax, x, err, xlabel, letter):
    xlim = np.array([0,1])
    for i in range(3):
        ax.scatter(x[:,i], err[:,i], color='rgb'[i])
    ax.legend(['red channel','green channel','blue channel'], frameon=False, loc='lower right')
    ax.plot(xlim,(-1/255)*np.ones(2),'k-')
    ax.plot(xlim,(1/255)*np.ones(2),'k-')
    ax.set_xlabel(xlabel, fontsize=18)
    ax.set_ylabel('prediction error', fontsize=18)
    ax.set_xlim(xlim)
    ax.set_ylim((-0.02,0.01))
    ax.set_aspect(1./ax2.get_data_ratio())
    ax.text(0.85,-0.012,letter,fontsize=24)

# plot prediction error in v_k against actual v_k
ax2 = fig.add_subplot(2,2,2)
k = np.random.randint(low=0, high=v.shape[0], size=200)
plot_err(ax2, v[k,:], v_hat[k,:] - v[k,:], 'actual $v_k$', '(b)')

# plot prediction error in v_k against m_k
ax3 = fig.add_subplot(2,2,3)
plot_err(ax3, m[k,:], v_hat[k,:] - v[k,:], 'material color $m_k$', '(c)')

# plot prediction error in v_k against actual v_k, without low values of m_k
ax4 = fig.add_subplot(2,2,4)
vv = v[k,:]
vv[m[k,:] < 0.2] = np.nan;
plot_err(ax4, vv, v_hat[k,:] - v[k,:], 'actual $v_k$', '(d)')

plt.savefig(f'figures/model_test_2_L{int(testLambertian)}_T{int(testTonemapping)}.pdf', bbox_inches='tight')
plt.show()
