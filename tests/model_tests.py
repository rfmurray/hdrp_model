# model_tests.py  Test HDRP model model predictions

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from hdrp import srgb, srgbinv, TonemapCube, cubetag

# choose whether to test results from model_test Unity project with
# Lambertian or unlit material
testLambertian = True

# choose cube file
# - if filename is empty, then test is done without tonemapping
cubefile = 'cube/linear_max1.cube'
cubefile = ''

# load data generated by Unity project render_random
testTonemapping = len(cubefile) > 0
fname = f'data/data_L{int(testLambertian)}_T{int(testTonemapping)}{cubetag(cubefile)}.txt'
df = pd.read_csv(fname)

# discard samples that may be maxed out
k = (df[['v_r','v_g','v_b']] <= 0.99).all(axis=1)
df = df[k]

# create numpy arrays for model parameters
e = df['e'].to_numpy().reshape((-1,1))       # exposure
m = df[['m_r','m_g','m_b']].to_numpy()       # material color
d = df[['d_r','d_g','d_b']].to_numpy()       # directional light color
a = df[['a_r','a_g','a_b']].to_numpy()       # ambient light color
v = df[['v_r','v_g','v_b']].to_numpy()       # post-processed color
i_d = df['i_d'].to_numpy().reshape((-1,1))   # directional light intensity
i_a = df['i_a'].to_numpy().reshape((-1,1))   # directional light intensity
l = df[['l_x','l_y','l_z']].to_numpy()       # lighting direction
n = df[['n_x','n_y','n_z']].to_numpy()       # plane surface normal
costheta = (l*n).sum(axis=1, keepdims=True)  # cosine of angle between lighting direction and plane surface normal

# apply Lambertian rendering model to get predicted rendered color
# coordinates u_k
if testLambertian:
    c = 0.822
    u_hat = c * srgb(m) * ( i_d * srgb(d) * costheta.clip(min=0) / np.pi + i_a * a ) / (2**e)
else:
    u_hat = srgb(m)

# apply tonemapping
if testTonemapping:
    
    tonemap = TonemapCube(cubefile)
    
    # estimates from delta functions
    tonemap.u_knot = np.array([0, 1e-09, 0.00026059, 0.00310441, 0.00730495, 0.0128806, 0.0205608, 0.0306122, 0.0446793, 0.0639257, 0.0905573, 0.124511, 0.171195, 0.235383, 0.323638, 0.440577, 0.59383, 0.816481, 1.1115, 1.49813, 2.03945, 2.77635, 3.77952, 5.09423, 6.93491, 9.44068, 12.7246, 17.3224, 23.3479, 31.7842, 43.2686, 58.9028])
    
    # estimates from optimizing model for identity.cube
    # tonemap.u_knot = np.array([0, 1e-09, 1e-08, 0.00294563, 0.007079, 0.0127072, 0.0203262, 0.0310003, 0.04502, 0.0642561, 0.0899971, 0.125695, 0.17349, 0.237149, 0.327206, 0.441861, 0.609533, 0.822935, 1.10384, 1.49459, 2.03212, 2.75649, 3.73814, 5.08289, 6.86428, 9.34713, 12.6195, 17.1796, 23.2405, 31.4807, 42.7522, 57.6644])
    
    # estimates from optimizing model for sawtooth.cube
    # tonemap.u_knot = np.array([0, 1e-09, 1.72394e-06, 0.00287276, 0.00711896, 0.012538, 0.0203906, 0.0303822, 0.044594, 0.0631651, 0.0894389, 0.123654, 0.172001, 0.234461, 0.323087, 0.438583, 0.601776, 0.815277, 1.10384, 1.49459, 2.03212, 2.75649, 3.73814, 5.08289, 6.86428, 9.34713, 12.6195, 17.1796, 23.2405, 31.4807, 42.7522, 57.6644])

    # estimates from optimizing model for several nonlinearities
    # tonemap.u_knot = np.array([0, 1e-09, 9.82132e-09, 0.00284923, 0.00719612, 0.0127425, 0.0205489, 0.0309998, 0.0450249, 0.0641519, 0.0901781, 0.12527, 0.172976, 0.237221, 0.325983, 0.44253, 0.604314, 0.821369, 1.10384, 1.49459, 2.03212, 2.75649, 3.73814, 5.08289, 6.86428, 9.34713, 12.6195, 17.1796, 23.2405, 31.4807, 42.7522, 57.6644])

    t_hat = tonemap.apply(u_hat)
else:
    t_hat = u_hat

# apply inverse sRGB nonlinearity to get post-processed color coordinates v_k
v_hat = srgbinv(t_hat)

# print(255*np.median(abs(v_hat-v)))

# plot predicted post-processed color coordinates v_k against actual v_k
plotFour = testLambertian # and not testTonemapping
plotFour = False
if plotFour:
    fig = plt.figure(figsize=(13,12))
    ax1 = fig.add_subplot(2,2,1)
else:
    fig = plt.figure(figsize=(13,5.5))
    ax1 = fig.add_subplot(1,2,1)
xylim = np.array([0,1.1])
k = np.random.randint(low=0, high=v.shape[0], size=50)
for i in range(3):
    ax1.scatter(v[k,i], v_hat[k,i], color='rgb'[i])
ax1.plot(xylim, xylim, 'k-')
ax1.legend(['red channel','green channel','blue channel'], frameon=False, loc='upper left')
ax1.set_xlabel('actual $v_k$', fontsize=18)
ax1.set_ylabel('predicted $v_k$', fontsize=18)
ax1.set_xlim(xylim)
ax1.set_ylim(xylim)
ax1.set_aspect(1)
ax1.text(0.92,0.75,'(a)',fontsize=24)

# plot prediction error against another scene parameter
def plot_err(ax, x, err, xlabel, letter):
    xlim = np.array([0,1])
    for i in range(3):
        ax.scatter(x[:,i], err[:,i], color='rgb'[i])
    ax.legend(['red channel','green channel','blue channel'], frameon=False, loc='lower right')
    ax.plot(xlim,(-1/255)*np.ones(2),'k-')
    ax.plot(xlim,(1/255)*np.ones(2),'k-')
    ax.set_xlabel(xlabel, fontsize=18)
    ax.set_ylabel('prediction error', fontsize=18)
    ax.set_xlim(xlim)
    ax.set_ylim((-0.02,0.02))
    ax.set_aspect(1./ax2.get_data_ratio())
    ax.text(0.8,0.015,letter,fontsize=24)

# plot prediction error in v_k against actual v_k
if plotFour:
    ax2 = fig.add_subplot(2,2,2)
else:
    ax2 = fig.add_subplot(1,2,2)
k = np.random.randint(low=0, high=v.shape[0], size=200)
plot_err(ax2, v[k,:], v_hat[k,:] - v[k,:], 'actual $v_k$', '(b)')

if plotFour:
    
    # plot prediction error in v_k against m_k
    ax3 = fig.add_subplot(2,2,3)
    plot_err(ax3, m[k,:], v_hat[k,:] - v[k,:], 'material color $m_k$', '(c)')
    
    # plot prediction error in v_k against actual v_k, without low values of m_k
    ax4 = fig.add_subplot(2,2,4)
    vv = v[k,:]
    vv[m[k,:] < 0.2] = np.nan;
    plot_err(ax4, vv, v_hat[k,:] - v[k,:], 'actual $v_k$', '(d)')
    
plt.savefig(f'figures/model_tests_L{int(testLambertian)}_T{int(testTonemapping)}.pdf', bbox_inches='tight')
plt.show()
