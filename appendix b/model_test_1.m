% model_test_1.m  Find rendering scale constant c for Lambertian materials
%                 (see equation (2) in main text)

% See readme_appendix_b.txt for details about how to run this test.

clear; clc;

addpath ../tools

% load data generated by Unity project model_test with a Lambertian
% material and tonemapping set to None
d = readtable('model_test/data_lambertian.txt');

% use dot product to find cosine of angle between lighting direction and
% test plane surface normal
costheta = d.lightDirX .* d.planeNormalX + d.lightDirY .* d.planeNormalY + d.lightDirZ .* d.planeNormalZ;

% find rendering model's predictions for rendered color coordinates u_k,
% without scale constant c
uRhat = srgb(d.planeColorR) .* ( d.directionalIntensity .* srgb(d.directionalColorR) .* max(costheta, 0) / pi + d.ambientMultiplier .* d.ambientColorR );
uGhat = srgb(d.planeColorG) .* ( d.directionalIntensity .* srgb(d.directionalColorG) .* max(costheta, 0) / pi + d.ambientMultiplier .* d.ambientColorG );
uBhat = srgb(d.planeColorB) .* ( d.directionalIntensity .* srgb(d.directionalColorB) .* max(costheta, 0) / pi + d.ambientMultiplier .* d.ambientColorB );

% get actual post-processed color coordinates v_k
vR = d.renderR;
vG = d.renderG;
vB = d.renderB;

% apply sRGB nonlinearity to get actual rendered color coordinates u_k
uR = srgb(vR);
uG = srgb(vG);
uB = srgb(vB);

% discard data points with either coordinate outside [ 0, 0.95 ]
[uR, uRhat] = trim(uR, uRhat);
[uG, uGhat] = trim(uG, uGhat);
[uB, uBhat] = trim(uB, uBhat);

% plot predicted rendered color coordinates u_k, without scale constant c,
% against actual coordinates
xylim = [ 0 1.1 ];
plot(xylim, xylim, 'k--');
hold on
hr = plot(uR, uRhat, 'ro', 'MarkerFaceColor', 'r', 'MarkerSize', 10);
hg = plot(uG, uGhat, 'go', 'MarkerFaceColor', 'g', 'MarkerSize', 10);
hb = plot(uB, uBhat, 'bo', 'MarkerFaceColor', 'b', 'MarkerSize', 10);
hold off
axis square
axis([ xylim xylim ]);
xlabel 'actual u_k'
ylabel 'predicted u_k'
legend([hr hg hb], 'red channel', 'green channel', 'blue channel', 'location', 'northwest', 'box', 'off', 'AutoUpdate', 'off');
set(gca,'FontSize',18);

% find regression slope of above plot
uK = [ uR ; uG ; uB ];
uKhat = [ uRhat ; uGhat ; uBhat ];
r = regress(uKhat, uK);

% add regression line to plot
hold on
plot(xlim, r*xlim, 'r-');
hold off
print -dpdf model_test_1.pdf

% the scale constant that will adjust the predicted renderd color
% coordinates u_k so that they fall on the line y=x is the inverse
% of the regression slope
c = 1/r;
fprintf('rendering model scale constant: c = %.3f\n', c);

function [uK, uKhat] = trim(uK, uKhat)
% discard elements in uK and corresponding elements in uKhat if either
% element is outside [0, 0.95]
k = uK >= 0 & uKhat >= 0 & uK <= 0.95 & uKhat <= 0.95;
uK = uK(k);
uKhat = uKhat(k);
end
