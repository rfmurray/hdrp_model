% model_test_2.m  Test rendering and post-processing models for Lambertian
%                 and unlit materials

% See readme_appendix_b.txt for details about how to run this test.

clear; clc;

% addpath ../tools
addpath tools

% choose whether to test results from model_test Unity project with
% a Lambertian or an unlit material
testLambertian = true;
testTonemapping = true;
cubefile = 'model_test/Assets/square_root.cube';

% load data generated by Unity project model_test for this condition
fname = filename(testLambertian, testTonemapping);
data = readtable(fname);

% combine columns into m x 3 matrices
m = [ data.planeColorR data.planeColorG data.planeColorB ];
d = [ data.directionalColorR data.directionalColorG data.directionalColorB ];
a = [ data.ambientColorR data.ambientColorG data.ambientColorB ];

% apply Lambertian or unlit rendering model
if testLambertian
    c = 0.822;
    costheta = data.lightDirX .* data.planeNormalX + data.lightDirY .* data.planeNormalY + data.lightDirZ .* data.planeNormalZ;
    u = c * srgb(m) .* ( data.directionalIntensity .* srgb(d) .* max(costheta, 0) / pi + data.ambientMultiplier .* a );
else
    u = srgb(m);
end

% apply tonemapping
if testTonemapping
    tonemap = TonemapCube(cubefile);
    tonemap.u_knot = [ 0 1e-09 1.402e-05 0.003089 0.007417 0.01272 0.021 0.03146 0.04521 0.06482 0.09131 0.126 0.1736 0.2381 0.3303 0.4483 0.6096 0.8295 1.124 1.498 2.039 2.766 3.76 5.072 6.871 9.398 12.65 17.25 23.25 31.41 43.01 57.74 ];
    tonemap.makecoord;
    t = tonemap.apply(u);
else
    t = u;
end

% apply sRGB nonlinearity to get post-processed color coordinates v_k
v = srgbinv(t);

% plot predicted post-processed color coordinates v_k against actual,
% rendered coordinates; just plot a subset, so that results for the blue
% channel (which are plotted last) don't cover up results for the red
% and green channels
figure(1);
xylim = [ 0 1.2 ];
plot(xylim, xylim, 'k-');
hold on
hr = plot(data.renderR(1:30), v(1:30,1), 'ro', 'MarkerFaceColor', 'r', 'MarkerSize', 8);
hg = plot(data.renderG(1:30), v(1:30,2), 'go', 'MarkerFaceColor', 'g', 'MarkerSize', 8);
hb = plot(data.renderB(1:30), v(1:30,3), 'bo', 'MarkerFaceColor', 'b', 'MarkerSize', 8);
hold off
axis square
axis([ xylim xylim ]);
xlabel 'actual v_k'
ylabel 'predicted v_k'
legend([hr hg hb], 'red channel', 'green channel', 'blue channel', 'location', 'northwest', 'box', 'off');
set(gca,'FontSize',18);
print -dpdf model_test_2a.pdf
print -depsc2 model_test_2a.eps

figure(2);
xlim = [ 0 1 ];
hr = plot(data.renderR,v(:,1)-data.renderR, 'ro', 'MarkerFaceColor', 'r', 'MarkerSize', 8);
hold on
hg = plot(data.renderG,v(:,2)-data.renderG,'go', 'MarkerFaceColor', 'g', 'MarkerSize', 8);
hb = plot(data.renderB,v(:,3)-data.renderB,'bo', 'MarkerFaceColor', 'b', 'MarkerSize', 8);
plot(xlim,(-1/255)*[ 1 1 ],'k-');
plot(xlim,(1/255)*[ 1 1 ],'k-');
hold off
axis square
axis([ xlim (5/255)*[ -1 1 ] ]);
xlabel 'actual v_k'
ylabel 'prediction error for v_k'
legend([hr hg hb], 'red channel', 'green channel', 'blue channel', 'location', 'northwest', 'box', 'off');
set(gca,'FontSize',18);
print -dpdf model_test_2b.pdf
print -depsc2 model_test_2b.eps

function f = filename(lambertian, tonemap)
f = 'model_test/data';
if lambertian
    f = [ f '_lambertian' ];
else
    f = [ f '_unlit'; ];
end
if tonemap
    f = [ f '_tonemap' ];
else
    f = [ f '_notonemap' ];
end
f = [ f '.txt' ];
end
