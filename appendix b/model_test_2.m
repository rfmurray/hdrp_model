% model_test_2.m  Test rendering and post-processing models for Lambertian
%                 and unlit materials

% See readme_appendix_b.txt for details about how to run this test.

clear; clc;

% addpath ../tools
addpath tools

% choose whether to test results from model_test Unity project with
% a Lambertian or an unlit material
testLambertian = true;
testTonemapping = false;

if testTonemapping
    tonemap = TonemapCube('model_test/Assets/square.cube');
    tonemap.method = 'linear';
end

filename = 'model_test/data';
if testLambertian
    filename = [ filename '_lambertian' ];
else
    filename = [ filename '_unlit'; ];
end
if testTonemapping
    filename = [ filename '_tonemap' ];
else
    filename = [ filename '_notonemap' ];
end
filename = [ filename '.txt' ];

if testLambertian

    % load data generated by Unity project model_test with a Lambertian material
    d = readtable(filename);

    % use dot product to find cosine of angle between lighting direction
    % and test plane surface normal
    costheta = d.lightDirX .* d.planeNormalX + d.lightDirY .* d.planeNormalY + d.lightDirZ .* d.planeNormalZ;

    % find rendering model's predictions for rendered color coordinates u_k
    % (exposure in Unity project model_test is set to zero)
    c = 0.822;
    u_r = c * srgb(d.planeColorR) .* ( d.directionalIntensity .* srgb(d.directionalColorR) .* max(costheta, 0) / pi + d.ambientMultiplier .* d.ambientColorR );
    u_g = c * srgb(d.planeColorG) .* ( d.directionalIntensity .* srgb(d.directionalColorG) .* max(costheta, 0) / pi + d.ambientMultiplier .* d.ambientColorG );
    u_b = c * srgb(d.planeColorB) .* ( d.directionalIntensity .* srgb(d.directionalColorB) .* max(costheta, 0) / pi + d.ambientMultiplier .* d.ambientColorB );

    % apply tonemapping
    if testTonemapping
        t_r = NaN(size(u_r));
        t_g = NaN(size(u_g));
        t_b = NaN(size(u_b));
        for i = 1:numel(u_r)
            tRGB = tonemap.apply([u_r(i) u_g(i) u_b(i)]);
            t_r(i) = tRGB(1);
            t_g(i) = tRGB(2);
            t_b(i) = tRGB(3);
        end
    else
        t_r = u_r;
        t_g = u_g;
        t_b = u_b;
    end

    % apply sRGB nonlinearity to get predictions for post-processed color
    % coordinates v_k
    v_r = srgbinv(t_r);
    v_g = srgbinv(t_g);
    v_b = srgbinv(t_b);

else

    % load data generated by Unity project model_test with an unlit material
    d = readtable(filename);

    u_r = srgb(d.planeColorR);
    u_g = srgb(d.planeColorG);
    u_b = srgb(d.planeColorB);

    % apply tonemapping
    if testTonemapping
        t_r = NaN(size(u_r));
        t_g = NaN(size(u_g));
        t_b = NaN(size(u_b));
        for i = 1:numel(u_r)
            tRGB = tonemap.apply([u_r(i) u_g(i) u_b(i)]);
            t_r(i) = tRGB(1);
            t_g(i) = tRGB(2);
            t_b(i) = tRGB(3);
        end
    else
        t_r = u_r;
        t_g = u_g;
        t_b = u_b;
    end

    % apply sRGB nonlinearity to get predictions for post-processed color
    % coordinates v_k
    v_r = srgbinv(t_r);
    v_g = srgbinv(t_g);
    v_b = srgbinv(t_b);

end

% plot predicted post-processed color coordinates v_k against actual,
% rendered coordinates; just plot a subset, so that results for the blue
% channel (which are plotted last) don't cover up results for the red
% and green channels
figure(1);
xylim = [ 0 1.2 ];
plot(xylim, xylim, 'k-');
hold on
hr = plot(d.renderR(1:30), v_r(1:30), 'ro', 'MarkerFaceColor', 'r', 'MarkerSize', 8);
hg = plot(d.renderG(1:30), v_g(1:30), 'go', 'MarkerFaceColor', 'g', 'MarkerSize', 8);
hb = plot(d.renderB(1:30), v_b(1:30), 'bo', 'MarkerFaceColor', 'b', 'MarkerSize', 8);
hold off
axis square
axis([ xylim xylim ]);
xlabel 'actual v_k'
ylabel 'predicted v_k'
legend([hr hg hb], 'red channel', 'green channel', 'blue channel', 'location', 'northwest', 'box', 'off');
set(gca,'FontSize',18);
print -dpdf model_test_2a.pdf
print -depsc2 model_test_2a.eps

figure(2);
xlim = [ 0 1 ];
hr = plot(d.renderR,v_r-d.renderR, 'ro', 'MarkerFaceColor', 'r', 'MarkerSize', 8);
hold on
hg = plot(d.renderG,v_g-d.renderG,'go', 'MarkerFaceColor', 'g', 'MarkerSize', 8);
hb = plot(d.renderB,v_b-d.renderB,'bo', 'MarkerFaceColor', 'b', 'MarkerSize', 8);
plot(xlim,(-1/255)*[ 1 1 ],'k-');
plot(xlim,(1/255)*[ 1 1 ],'k-');
hold off
axis square
axis([ xlim (5/255)*[ -1 1 ] ]);
xlabel 'actual v_k'
ylabel 'prediction error for v_k'
legend([hr hg hb], 'red channel', 'green channel', 'blue channel', 'location', 'northwest', 'box', 'off');
set(gca,'FontSize',18);
print -dpdf model_test_2b.pdf
print -depsc2 model_test_2b.eps
