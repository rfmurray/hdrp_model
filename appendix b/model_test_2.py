# model_test_2.py  Test rendering and post-processing models for Lambertian
#                  and unlit materials

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from hdrp import srgb, srgbinv

# choose whether to test results from model_test Unity project with
# Lambertian or unlit material
testLambertian = False

# choose whether to test results with or without tonemapping
testTonemapping = False
cubefile = 'square_root.cube'

# load data generated by Unity project render_random for this condition
fname = f'data_L{int(testLambertian)}_T{int(testTonemapping)}.txt'
df = pd.read_csv(fname)

# discard samples that may be maxed out
k = (df[['v_r','v_g','v_b']] <= 0.99).all(axis=1)
df = df[k]

# create numpy arrays for model parameters
e = df['e'].to_numpy().reshape((-1,1))       # exposure
m = df[['m_r','m_g','m_b']].to_numpy()       # material color
d = df[['d_r','d_g','d_b']].to_numpy()       # directional light color
a = df[['a_r','a_g','a_b']].to_numpy()       # ambient light color
v = df[['v_r','v_g','v_b']].to_numpy()       # post-processed color
i_d = df['i_d'].to_numpy().reshape((-1,1))   # directional light intensity
i_a = df['i_a'].to_numpy().reshape((-1,1))   # directional light intensity
l = df[['l_x','l_y','l_z']].to_numpy()       # lighting direction
n = df[['n_x','n_y','n_z']].to_numpy()       # plane surface normal
costheta = (l*n).sum(axis=1, keepdims=True)  # cosine of angle between lighting direction and plane surface normal

# apply Lambertian rendering model to get predicted rendered color
# coordinates u_k, without rendering scale constant c
if testLambertian:
    c = 0.822
    u_hat = c * srgb(m) * ( i_d * srgb(d) * costheta.clip(min=0) / np.pi + i_a * a ) / (2**e)
else:
    u_hat = srgb(m)


# apply tonemapping
if testTonemapping:
    t_hat = u_hat  # *** apply tonemapping here
else:
    t_hat = u_hat

# apply inverse sRGB nonlinearity to get post-processed color coordinates v_k
v_hat = srgbinv(t_hat)

p = (abs(v_hat-v) > 1.5/255).mean()
print(p)

# plot predicted post-processed color coordinates v_k against actual v_k
fig = plt.figure(figsize=(13,12))
ax1 = fig.add_subplot(2,2,1)
xylim = np.array([0,1.1])
k = np.random.randint(low=0, high=v.shape[0], size=50)
for i in range(3):
    ax1.scatter(v[k,i], v_hat[k,i], color='rgb'[i])
ax1.plot(xylim, xylim, 'k-')
ax1.legend(['red channel','green channel','blue channel'], frameon=False, loc='upper left')
ax1.set_xlabel('actual $v_k$', fontsize=18)
ax1.set_ylabel('predicted $v_k$', fontsize=18)
ax1.set_xlim(xylim)
ax1.set_ylim(xylim)
ax1.set_aspect(1)
ax1.text(0.85,0.1,'(a)',fontsize=24)

# plot prediction error in v_k against actual v_k
ax2 = fig.add_subplot(2,2,2)
xlim = np.array([0,1])
k = np.random.randint(low=0, high=v.shape[0], size=200)
for i in range(3):
    ax2.scatter(v[k,i], v_hat[k,i]-v[k,i], color='rgb'[i])
ax2.legend(['red channel','green channel','blue channel'], frameon=False, loc='lower right')
ax2.plot(xlim,(-1/255)*np.ones(2),'k-')
ax2.plot(xlim,(1/255)*np.ones(2),'k-')
ax2.set_xlabel('actual $v_k$', fontsize=18)
ax2.set_ylabel('prediction error', fontsize=18)
ax2.set_xlim(xlim)
ax2.set_ylim((-0.020,0.010))
ax2.set_aspect(1./ax2.get_data_ratio())
ax2.text(0.85,-0.012,'(b)',fontsize=24)

# plot prediction error in v_k against m_k
ax3 = fig.add_subplot(2,2,3)
xlim = np.array([0,1])
for i in range(3):
    ax3.scatter(m[k,i], v_hat[k,i]-v[k,i], color='rgb'[i])
ax3.legend(['red channel','green channel','blue channel'], frameon=False, loc='lower right')
ax3.plot(xlim,(-1/255)*np.ones(2),'k-')
ax3.plot(xlim,(1/255)*np.ones(2),'k-')
ax3.set_xlabel('material color $m_k$', fontsize=18)
ax3.set_ylabel('prediction error', fontsize=18)
ax3.set_xlim(xlim)
ax3.set_ylim((-0.020,0.010))
ax3.set_aspect(1./ax2.get_data_ratio())
ax3.text(0.85,-0.012,'(c)',fontsize=24)

# plot prediction error in v_k against l_k
ax4 = fig.add_subplot(2,2,4)
xlim = np.array([0,1])
for i in range(3):
    ax4.scatter(d[k,i], v_hat[k,i]-v[k,i], color='rgb'[i])
ax4.legend(['red channel','green channel','blue channel'], frameon=False, loc='lower right')
ax4.plot(xlim,(-1/255)*np.ones(2),'k-')
ax4.plot(xlim,(1/255)*np.ones(2),'k-')
ax4.set_xlabel('directional light color $d_k$', fontsize=18)
ax4.set_ylabel('prediction error', fontsize=18)
ax4.set_xlim(xlim)
ax4.set_ylim((-0.020,0.010))
ax4.set_aspect(1./ax2.get_data_ratio())
ax4.text(0.85,-0.012,'(c)',fontsize=24)

print(l)

plt.savefig(f'model_test_2_L{int(testLambertian)}_T{int(testTonemapping)}.eps', bbox_inches='tight')
plt.show()
