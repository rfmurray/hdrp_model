% model_test_2_fit.m  Test rendering and post-processing models for Lambertian
%                     and unlit materials, and fit tonemapping knot points

clear; clc;

addpath hdrp

% choose whether to test results from model_test Unity project with
% Lambertian or unlit material
testLambertian = true;

% choose whether to test results with or without tonemapping
testTonemapping = true;
cubefile = 'identity.cube';

% load data generated by Unity project render_random for this condition
fname = sprintf('data_L%d_T%d.txt', testLambertian, testTonemapping);
data = readtable(fname);

% discard samples that may be maxed out
k = data.v_r <= 0.99 & data.v_g <= 0.99 & data.v_b <= 0.99;
data = data(k,:);

% tranform table into model parameters
e = data.e;                          % exposure
m = [ data.m_r data.m_g data.m_b ];  % material color
d = [ data.d_r data.d_g data.d_b ];  % directional light color
a = [ data.a_r data.a_g data.a_b ];  % ambient light color
v = [ data.v_r data.v_g data.v_b ];  % post-processed color
i_d = data.i_d;                      % directional light intensity
i_a = data.i_a;                      % ambient light intensity
l = [ data.l_x data.l_y data.l_z ];  % lighting direction
n = [ data.n_x data.n_y data.n_z ];  % plane normal
costheta = sum(l .* n, 2);

% apply Lambertian or unlit rendering model
if testLambertian
    c = 0.822;
    u_hat = c * srgb(m) .* ( i_d .* srgb(d) .* max(costheta, 0) / pi + i_a .* a ) ./ (2.^e);
else
    u_hat = srgb(m);
end

% apply tonemapping
if testTonemapping
    tonemap = TonemapCube(cubefile);
    t_hat = tonemap.apply(u_hat);
else
    t_hat = u_hat;
end

% apply sRGB nonlinearity to get post-processed color coordinates v_k
v_hat = srgbinv(t_hat);

% err = v_hat-v;
% hold on
% c = 'rgb';
% for i = 1:3
%     plot(m(:,i), err(:,i), [ c(i) 'o' ], 'MarkerFaceColor', c(i));
% end
% hold off
% 
% % set(gca,'YLim',[-2/255 2/255]);
% 
% return

% plot predicted post-processed color coordinates v_k against actual v_k
figure(1);
xylim = [ 0 1 ];
k = unidrnd(size(v,1),[50 1]);
h = scatter(v(k,:),v_hat(k,:),80,[ 1 0 0 ; 0 1 0 ; 0 0 1 ],'filled');
legend(h, 'red channel', 'green channel', 'blue channel', 'location', 'northwest', 'box', 'off', 'AutoUpdate', 'off');
hold on
plot(xylim, xylim, 'k-');
hold off
box on
axis square
axis([ xylim xylim ]);
xlabel 'actual v_k'
ylabel 'predicted v_k'
set(gca,'FontSize',18);
h = text(0.85,0.1,'(a)');
h.FontSize = 24;

% plot prediction error in v_k against actual v_k
figure(2);
xlim = [ 0 1 ];
k = unidrnd(size(v,1),[200 1]);
h = scatter(v(k,:),v_hat(k,:)-v(k,:),80,[ 1 0 0 ; 0 1 0 ; 0 0 1 ],'filled');
hold on
plot(xlim,(-1/255)*[ 1 1 ],'k-');
plot(xlim,(1/255)*[ 1 1 ],'k-');
hold off
box on
axis square
axis([ xlim (5/255)*[ -1 1 ] ]);
xlabel 'actual v_k'
ylabel 'prediction error for v_k'
legend(h, 'red channel', 'green channel', 'blue channel', 'location', 'northwest', 'box', 'off');
set(gca,'FontSize',18);
h = text(0.85,-0.015,'(b)');
h.FontSize = 24;


nknot = numel(tonemap.u_knot(3:19));

A = eye(nknot) + diag(repmat(-1,[1 nknot-1]),1);
A = A(1:end-1,:);
B = zeros([ size(A,1) 1]);

LB = -Inf([ nknot 1]);
LB(1) = 1e-8;

UB = Inf([ nknot 1]);
UB(end) = 1.4;

errfn2 = @(p) errfn(p, tonemap, u_hat, v, A, B, LB, UB);
pinit = tonemap.u_knot(3:19)';

% A * pinit <= B
% pinit >= LB
% pinit <= UB

phat = fmincon(errfn2, pinit, A, B, [], [], LB, UB);

tonemap.u_knot(3:19) = phat;

t_hat = tonemap.apply(u_hat);
v_hat = srgbinv(t_hat);


function err = errfn(param, tonemap, u_hat, v, A, B, LB, UB)

constraintsAB = A * param <= B;
constraintsLB = param >= LB;
constraintsUB = param <= UB;
if ~all(constraintsAB) || ~all(constraintsLB) || ~all(constraintsUB)
    err = Inf;
    return
end

tonemap.u_knot(3:19) = param;

t_hat = tonemap.apply(u_hat);
v_hat = srgbinv(t_hat);
err = sum((v-v_hat).^2, "all");

end
